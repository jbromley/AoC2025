#!/bin/bash
set -Eeuo

YEAR=2025
AOC_BASE_URL="https://adventofcode.com/${YEAR}"

# Function to create a new Advent of Code solution for a given day
create_new_solution() {
  local day="$1"
  local padded_day
  padded_day="$(printf '%02d' ${number})"

  echo "Creating a new Advent of Code template for day ${day}."

  if [ -f "./.env" ]; then
    echo "found .env file..."
    export "$(grep -v '^#' .env | xargs)"

  fi

  # Create a directory for the day
  mkdir -p solutions/inputs
  mkdir -p solutions/src

  # Create the Haskell solution file
  module_template="module Main where

import System.Environment (getArgs)
import Data.ByteString qualified as B

{- Types for your input and your solution

- Input    should as the type of your input parameter. AOC, typically uses arrays, matrices or complex data structures.
- Solution should be the type of your solution. Typically is an Int, but It can be other things, like a list of numbers
         or a list of characters
-}
type Input    = B.ByteString  -- default to Bytestring, but very likely you'll need to change it
type Solution = Int

-- | parser transforms a raw bytestring (from your ./input/day-X.input) to your Input type.
--   this is intended to use attoparsec for such a transformation. You can use Prelude's
--   String if it fit better for the problem
parser :: B.ByteString -> Input
parser = undefined

-- | The function which calculates the solution for part one
solve1 :: Input -> Solution
solve1 = error \"Part 1 Not implemented\"

-- | The function which calculates the solution for part two
solve2 :: Input -> Solution
solve2 = error \"Part 2 Not implemented\"

main :: IO ()
main = do
  -- run this with cabal run -- day-x <part-number> <file-to-solution>
  -- example: cabal run -- day-3 2 \"./input/day-3.example\"
  -- will run part two of day three with input file ./input/day-3.example
  [part, filepath] <- getArgs
  input <- parser <$> B.readFile filepath -- use parser <$> readFile filepath if String is better
  if read @Int part == 1
    then do
      putStr \"Day ${number} part 1: \"
      print $ solve1 input
    else do
      putStr \"Day ${number} part 2: \"
      print $ solve2 input
"
  echo Creating files...

  echo "$module_template" > "./solutions/src/${padded_day}.hs"

  # Create an empty input file
  touch "./solutions/inputs/${padded_day}-ex.txt"

  # Download the input data from Advent of Code
  if [ "$download" == true ]; then

    # Ensure that the AOC_SESSION cookie is set
    if [ -z "$AOC_SESSION" ]; then
      echo "AOC_SESSION is not set. Please provide your Advent of Code session cookie:"
      read -r AOC_SESSION
    fi

    curl -o "./solutions/inputs/${padded_day}.txt" --cookie "session=${AOC_SESSION}" -A "curl-aoc" "${AOC_BASE_URL}/day/${day}/input"
  else
    touch "./solutions/inputs/${padded_day}.txt"
  fi

  # Append the day to the advent-of-code.cabal file
  cabal_day="executable day-${padded_day}
  import: day
  main-is: ${padded_day}.hs
"
  echo "$cabal_day" >> solutions/solutions.cabal

  echo "Created a new Advent of Code solution for day ${day}"
}

run_solution() {
  local number="$1"
  local part="$2"
  local file_name="$3"
  local exe_file="day-$number"

  # Check if the file exists
  if [ ! -f "$file_name" ]; then
    echo "input file $file_name does not exist."
    exit 1
  fi

  # Check if the number is a positive integer
  if ! [[ "$number" =~ ^(0[1-9]|1[0-2])$ ]]; then
    echo "Invalid day: $number. It should be between 1 and 12"
    exit 1
  fi

  # Check if the number is a positive integer
  if ! [[ "$part" =~ ^[1-2]+$ ]]; then
    echo "Invalid part number: $part. It should be 1 or 2"
    exit 1
  fi

  cabal run "$exe_file" -- "$part" "$file_name"
}

main() {
  local subcommand
  local number
  local padded_number
  local run_command
  local run_filename
  local part

  # Check if the first argument is a subcommand and shift it out
  if [ "$1" == "new" ] || [ "$1" == "run" ]; then
    subcommand="$1"
    shift
  fi

  while getopts ":d:-:f:ei:p:" opt; do
    case $opt in
      d)
        number="${OPTARG}"
        padded_number=$(printf '%02d' "${number}")
        ;;
      f)
        run_command=f
        run_filename="$OPTARG"
        ;;
      e)
        run_command=example
        ;;
      i)
        run_command=input
        ;;
      -)
        run_command="$OPTARG"
        ;;
      p)
        part="$OPTARG"
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." >&2
        exit 1
        ;;
    esac
  done

  # Now you can check the parsed options and execute the corresponding actions.
  if [ "$subcommand" == "new" ]; then
    if [ -z "$number" ]; then
      echo "Missing day for 'new' command."
      exit 1
    fi

    if [ -z "$run_command" ]; then
      download=true
    fi

    case "$run_command" in
      no-curl)
        download=false
        ;;
    esac

    create_new_solution "$number"

  elif [ "$subcommand" == "run" ]; then
    if [ -z "$number" ]; then
      echo "Missing day for 'run' command. Use option -d <day-number>"
      exit 1
    fi

    if [ -z "$part" ]; then
      echo "Missing part for 'run' command. Use option -p <part-number>"
      exit 1
    fi

    if [ -z "$run_command" ]; then
      # Default to '--input' if no filename is provided
      run_command=input
    fi

    case "$run_command" in
      example)
        run_filename="./solutions/inputs/$number-ex.txt"
        ;;
      input)
        run_filename="./solutions/inputs/$number.txt"
        ;;
      f) ;;
      *)
        echo "unknown file. Use -f <file-path> for custom files"
    esac

    run_solution "$padded_number" "$part" "$run_filename"

  else
    echo "Usage: aoc-hs [new -d <day> [--no-curl] | run -d <day> -p <part> [-f <file-name> | --example | -e | --input | -i]]

Description:
  This tool simplifies Advent of Code solutions in Haskell by creating templates and handling input files. No need to learn Cabal!

Subcommand: new

Create a new Advent of Code solution for the specified day. It creates a main module, modifies the .cabal file, and downloads the input data.

Usage: aoc-hs new -d <day>
Example: aoc-hs new -d 3
         aoc-hs new -d 3 --no-curl
Options:
  -d <day>       Specify the day for the Advent of Code puzzle (1-25).
  --no-curl      It wont download your personal AoC input file. You don't have you provide a cookie with this option

Subcommand: run

Run an Advent of Code solution for the specified day and part. The input data is read from a file which can be supplied via -f or you can
use shortcuts --example and --input. Default --input

Usage: aoc-hs run -d <day> -p <part> [-f <file-name> | --example | -e | --input | -i]
Example: aoc-hs run -d 3 -p 2 --example
         aoc-hs run -d 3 -p 3 -e
         aoc-hs run -d 3 -p 2 --input
         aoc-hs run -d 3 -p 2 -i
         aoc-hs run -d 3 -p 2 -f my-input-file.txt
Options:
  -d <day>       Specify the day for the Advent of Code puzzle (1-25).
  -p <part>      Specify the part of the puzzle (1 or 2).
  -f <file-name> Specify a custom input file to use.
  --example, -e  Use the example input file (./inputs/day-<day>.example) as input.
  --input, -i    (Default) Use the puzzle input file (./inputs/day-<day>.input) as input.
"
    exit 1
  fi
}

main "$@"
